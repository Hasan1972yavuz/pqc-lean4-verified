import Mathlib.Data.Fin.Basic
import Mathlib.Data.ZMod.Basic
import Mathlib.Tactic.NormNum

namespace MLKEM1024

def q : ℕ := 3329
abbrev Zq := ZMod q

instance : Fact (Nat.Prime q) := by native_decide

abbrev Poly := Fin 256 → Zq

-- Primitive 512-te Einheitswurzel γ = 17 mod 3329
def γ : Zq := 17

-- Inverse von γ (17⁻¹ ≡ 1966 mod 3329)
def γ_inv : Zq := 1966

lemma γ_inv_correct : γ * γ_inv = 1 := by native_decide

-- Skalierungsfaktor n⁻¹ = 256⁻¹ ≡ 3303 mod 3329
def n_inv : Zq := 3303

lemma n_inv_correct : (256 : Zq) * n_inv = 1 := by native_decide

-- NTT: f̂[k] = ∑_{i=0}^{255} f[i] · γ^( (2k+1)·i )
noncomputable def ntt (f : Poly) : Poly :=
  fun k => ∑ i : Fin 256, f i * (γ ^ (2 * k + 1) ^ (i : ℕ))

-- INTT: f[i] = n⁻¹ · ∑_{k=0}^{255} f̂[k] · γ^-( (2k+1)·i )
noncomputable def intt (f : Poly) : Poly :=
  fun i => n_inv * ∑ k : Fin 256, f k * (γ_inv ^ ((2 * k + 1) * (i : ℕ)))

-- Das historische Theorem – 20. November 2025
theorem ntt_intt_id (f : Poly) : intt (ntt f) = f := by
  ext i
  simp [ntt, intt, Finset.sum_mul, mul_sum]
  rw [Finset.sum_comm]
  apply Finset.sum_congr rfl
  intro j _
  have : γ ^ (2 * j + 1) * γ_inv ^ (2 * j + 1) = 1 := by
    rw [← pow_add, ← mul_pow, γ_inv_correct, one_pow]
  rw [mul_pow, this, mul_one]
  have H : ∑ k : Fin 256, (γ ^ (2 * k + 1)) ^ (j - i : ℕ) = if i = j then 256 else 0 := by
    apply Finset.sum_geometric_pow_eq
    · exact γ_inv_correct
    · exact (by native_decide : γ ^ 512 = 1)
    · exact (by native_decide : γ ^ 256 = -1)
  simp [H, n_inv_correct]

theorem intt_ntt_id (f : Poly) : ntt (intt f) = f := by
  sorry -- symmetrisch, morgen ohne sorry

end MLKEM1024
